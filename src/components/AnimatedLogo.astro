---
const { class: className } = Astro.props;
---

<canvas class={`${className} ${"aspect-[484/70]"}`} id="logoCanvas"></canvas>

<script>
    import { Renderer, Geometry, Program, Mesh, Texture } from "ogl";
    const logoCanvas = document.getElementById("logoCanvas");

    // update image value with source once loaded
    const img = new Image();
    img.src = "/logo.png";

    const noiseImage = new Image();
    noiseImage.src = "/noise.jpg";

    img.onload = () => {
        const renderer = new Renderer({
            canvas: logoCanvas as HTMLCanvasElement,
            width: img.width,
            height: img.height,
            alpha: true,
        });

        logoCanvas.style.width = "100%";
        logoCanvas.style.height = "auto";
        const gl = renderer.gl;

        const texture = new Texture(gl);
        texture.image = img;

        const noiseTexture = new Texture(gl, {
            wrapS: gl.REPEAT,
            wrapT: gl.REPEAT,
            minFilter: gl.LINEAR_MIPMAP_LINEAR,
        });

        noiseTexture.image = noiseImage;

        const geometry = new Geometry(gl, {
            position: {
                size: 2,
                data: new Float32Array([-1, -1, 3, -1, -1, 3]),
            },
            uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },
        });

        const program = new Program(gl, {
            vertex: /* glsl */ `
            attribute vec2 uv;
            attribute vec2 position;

            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0, 1);
            }
        `,
            fragment: /* glsl */ `
            precision highp float;

            uniform float uTime;
            uniform vec2 uAspectRatio;
            uniform sampler2D uTexture;
            uniform sampler2D uNoiseTexture;
            varying vec2 vUv;

            float map(float value, float min1, float max1, float min2, float max2) {
              return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);
            }

            float circle(in vec2 _st, in float _radius){
                vec2 dist = _st-vec2(0.5);
	return 1.-smoothstep(_radius-(_radius*0.9),
                                     _radius+(_radius*0.09),
                                     dot(dist,dist)*2.0);
            }

            float rand(vec2 n) {
             	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
            }

            float noise(vec2 p){
             	vec2 ip = floor(p);
             	vec2 u = fract(p);
             	u = u*u*(3.0-2.0*u);

             	float res = mix(
              		mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
              		mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
             	return res*res;
            }

            void main() {
              vec4 color = texture2D(uTexture, vUv);
              vec3 noise1 = texture2D(uNoiseTexture, vec2(vUv.x * 0.3 + uTime, vUv.y * 0.05 + uTime)).rgb * 1.5;
              float noise2 = noise(vUv * 1000. + uTime * 100.);

              gl_FragColor.rgb = color.rgb;
              gl_FragColor.a = (color.a / noise1.r) - noise2 * 0.1;
              gl_FragColor.rgb = gl_FragColor.rgb * gl_FragColor.a;

            }
        `,
            uniforms: {
                uTime: { value: 0 },
                uTexture: { value: texture },
                uNoiseTexture: { value: noiseTexture },
                uMouse: { value: [0.5, 0.5] },
                uAspectRatio: { value: [1, img.height / img.width] },
            },
        });

        const mesh = new Mesh(gl, { geometry, program });

        requestAnimationFrame(update);
        function update(t) {
            requestAnimationFrame(update);

            program.uniforms.uTime.value = t * 0.00005;

            renderer.render({ scene: mesh });
        }
    };
</script>
