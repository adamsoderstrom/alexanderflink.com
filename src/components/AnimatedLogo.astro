---
const { class: className } = Astro.props;
---

<canvas class={`${className} ${"aspect-[484/70]"}`} id="logoCanvas"></canvas>

<script>
    import { Renderer, Geometry, Program, Mesh, Texture } from "ogl";
    const logoCanvas = document.getElementById("logoCanvas");

    // update image value with source once loaded
    const img = new Image();
    img.src = "/logo.png";
    img.onload = () => {
        const renderer = new Renderer({
            canvas: logoCanvas as HTMLCanvasElement,
            width: img.width,
            height: img.height,
            alpha: true,
        });

        logoCanvas.style.width = "100%";
        logoCanvas.style.height = "auto";
        const gl = renderer.gl;

        const texture = new Texture(gl);
        texture.image = img;

        const geometry = new Geometry(gl, {
            position: {
                size: 2,
                data: new Float32Array([-1, -1, 3, -1, -1, 3]),
            },
            uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },
        });

        const program = new Program(gl, {
            vertex: /* glsl */ `
            attribute vec2 uv;
            attribute vec2 position;

            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0, 1);
            }
        `,
            fragment: /* glsl */ `
            precision highp float;

            uniform float uTime;
            uniform float uFadeInDuration;
            uniform sampler2D uTexture;
            uniform vec2 uFocusPoint;

            varying vec2 vUv;

            float map(float value, float min1, float max1, float min2, float max2) {
              return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);
            }

            void main() {
                vec4 tex = texture2D(uTexture, vUv);
                float distanceToFocusPoint = distance(vUv * vec2(3.0, 1.0), uFocusPoint);
                float alpha = clamp(0.0, 1.0, tex.a * map(distanceToFocusPoint, 0.0, 0.5, 2.0, 1.0));
                // float alpha = smoothstep(1.0, 0.0, distanceToFocusPoint * 2.0);

                float fadeInAlpha = smoothstep(1.0, 0.0, vUv.x / (uTime * 0.6));

                gl_FragColor.rgb = tex.rgb;
                gl_FragColor.a = (tex.a * alpha);
                // gl_FragColor.a = tex.a;
                gl_FragColor.rgb *= gl_FragColor.a;
            }
        `,
            uniforms: {
                uTime: { value: 0 },
                uFocusPoint: { value: [0.0, 0.5] },
                uTexture: { value: texture },
            },
        });

        const mesh = new Mesh(gl, { geometry, program });

        requestAnimationFrame(update);
        function update(t) {
            requestAnimationFrame(update);

            program.uniforms.uTime.value = Math.max(0, t * 0.001 - 0.3);
            program.uniforms.uFocusPoint.value = [
                Math.sin(t * 0.0005) * 1.0 + 1.0,
                Math.sin(t * 0.001) * 0.5 + 0.5,
            ];

            // Don't need a camera if camera uniforms aren't required
            renderer.render({ scene: mesh });
        }
    };
</script>
